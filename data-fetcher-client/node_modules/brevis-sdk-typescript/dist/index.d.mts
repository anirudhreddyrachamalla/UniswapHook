import * as pb_1 from 'google-protobuf';

/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.3
 * source: common/circuit_data.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */

declare class AppCircuitInfo extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        output_commitment?: string;
        vk?: string;
        input_commitments?: string[];
        /** @deprecated*/
        toggles_commitment?: string;
        toggles?: boolean[];
        use_callback?: boolean;
        output?: string;
        vk_hash?: string;
        input_commitments_root?: string;
        witness?: string;
        max_receipts?: number;
        max_storage?: number;
        max_tx?: number;
        max_num_data_points?: number;
    });
    get output_commitment(): string;
    set output_commitment(value: string);
    get vk(): string;
    set vk(value: string);
    get input_commitments(): string[];
    set input_commitments(value: string[]);
    /** @deprecated*/
    get toggles_commitment(): string;
    /** @deprecated*/
    set toggles_commitment(value: string);
    get toggles(): boolean[];
    set toggles(value: boolean[]);
    get use_callback(): boolean;
    set use_callback(value: boolean);
    get output(): string;
    set output(value: string);
    get vk_hash(): string;
    set vk_hash(value: string);
    get input_commitments_root(): string;
    set input_commitments_root(value: string);
    get witness(): string;
    set witness(value: string);
    get max_receipts(): number;
    set max_receipts(value: number);
    get max_storage(): number;
    set max_storage(value: number);
    get max_tx(): number;
    set max_tx(value: number);
    get max_num_data_points(): number;
    set max_num_data_points(value: number);
    static fromObject(data: {
        output_commitment?: string;
        vk?: string;
        input_commitments?: string[];
        toggles_commitment?: string;
        toggles?: boolean[];
        use_callback?: boolean;
        output?: string;
        vk_hash?: string;
        input_commitments_root?: string;
        witness?: string;
        max_receipts?: number;
        max_storage?: number;
        max_tx?: number;
        max_num_data_points?: number;
    }): AppCircuitInfo;
    toObject(): {
        output_commitment?: string;
        vk?: string;
        input_commitments?: string[];
        toggles_commitment?: string;
        toggles?: boolean[];
        use_callback?: boolean;
        output?: string;
        vk_hash?: string;
        input_commitments_root?: string;
        witness?: string;
        max_receipts?: number;
        max_storage?: number;
        max_tx?: number;
        max_num_data_points?: number;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AppCircuitInfo;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): AppCircuitInfo;
}

/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.3
 * source: sdk/types.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */

declare class ReceiptData extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        block_num?: number;
        tx_hash?: string;
        fields?: Field[];
    });
    get block_num(): number;
    set block_num(value: number);
    get tx_hash(): string;
    set tx_hash(value: string);
    get fields(): Field[];
    set fields(value: Field[]);
    static fromObject(data: {
        block_num?: number;
        tx_hash?: string;
        fields?: ReturnType<typeof Field.prototype.toObject>[];
    }): ReceiptData;
    toObject(): {
        block_num?: number;
        tx_hash?: string;
        fields?: ReturnType<typeof Field.prototype.toObject>[];
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReceiptData;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): ReceiptData;
}
declare class Field extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        contract?: string;
        log_pos?: number;
        event_id?: string;
        value?: string;
        is_topic?: boolean;
        field_index?: number;
    });
    get contract(): string;
    set contract(value: string);
    get log_pos(): number;
    set log_pos(value: number);
    get event_id(): string;
    set event_id(value: string);
    get value(): string;
    set value(value: string);
    get is_topic(): boolean;
    set is_topic(value: boolean);
    get field_index(): number;
    set field_index(value: number);
    static fromObject(data: {
        contract?: string;
        log_pos?: number;
        event_id?: string;
        value?: string;
        is_topic?: boolean;
        field_index?: number;
    }): Field;
    toObject(): {
        contract?: string;
        log_pos?: number;
        event_id?: string;
        value?: string;
        is_topic?: boolean;
        field_index?: number;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Field;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): Field;
}
declare class StorageData extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        block_num?: number;
        address?: string;
        slot?: string;
        value?: string;
    });
    get block_num(): number;
    set block_num(value: number);
    get address(): string;
    set address(value: string);
    get slot(): string;
    set slot(value: string);
    get value(): string;
    set value(value: string);
    static fromObject(data: {
        block_num?: number;
        address?: string;
        slot?: string;
        value?: string;
    }): StorageData;
    toObject(): {
        block_num?: number;
        address?: string;
        slot?: string;
        value?: string;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StorageData;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): StorageData;
}
declare class TransactionData extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        hash?: string;
        chain_id?: number;
        block_num?: number;
        nonce?: number;
        gas_tip_cap_or_gas_price?: string;
        gas_fee_cap?: string;
        gas_limit?: number;
        from?: string;
        to?: string;
        value?: string;
    });
    get hash(): string;
    set hash(value: string);
    get chain_id(): number;
    set chain_id(value: number);
    get block_num(): number;
    set block_num(value: number);
    get nonce(): number;
    set nonce(value: number);
    get gas_tip_cap_or_gas_price(): string;
    set gas_tip_cap_or_gas_price(value: string);
    get gas_fee_cap(): string;
    set gas_fee_cap(value: string);
    get gas_limit(): number;
    set gas_limit(value: number);
    get from(): string;
    set from(value: string);
    get to(): string;
    set to(value: string);
    get value(): string;
    set value(value: string);
    static fromObject(data: {
        hash?: string;
        chain_id?: number;
        block_num?: number;
        nonce?: number;
        gas_tip_cap_or_gas_price?: string;
        gas_fee_cap?: string;
        gas_limit?: number;
        from?: string;
        to?: string;
        value?: string;
    }): TransactionData;
    toObject(): {
        hash?: string;
        chain_id?: number;
        block_num?: number;
        nonce?: number;
        gas_tip_cap_or_gas_price?: string;
        gas_fee_cap?: string;
        gas_limit?: number;
        from?: string;
        to?: string;
        value?: string;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TransactionData;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): TransactionData;
}
declare class CustomInput$1 extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        json_bytes?: string;
    });
    get json_bytes(): string;
    set json_bytes(value: string);
    static fromObject(data: {
        json_bytes?: string;
    }): CustomInput$1;
    toObject(): {
        json_bytes?: string;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CustomInput$1;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): CustomInput$1;
}
declare class IndexedReceipt extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        index?: number;
        data?: ReceiptData;
    });
    get index(): number;
    set index(value: number);
    get data(): ReceiptData;
    set data(value: ReceiptData);
    get has_data(): boolean;
    static fromObject(data: {
        index?: number;
        data?: ReturnType<typeof ReceiptData.prototype.toObject>;
    }): IndexedReceipt;
    toObject(): {
        index?: number;
        data?: ReturnType<typeof ReceiptData.prototype.toObject>;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IndexedReceipt;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): IndexedReceipt;
}
declare class IndexedStorage extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        index?: number;
        data?: StorageData;
    });
    get index(): number;
    set index(value: number);
    get data(): StorageData;
    set data(value: StorageData);
    get has_data(): boolean;
    static fromObject(data: {
        index?: number;
        data?: ReturnType<typeof StorageData.prototype.toObject>;
    }): IndexedStorage;
    toObject(): {
        index?: number;
        data?: ReturnType<typeof StorageData.prototype.toObject>;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IndexedStorage;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): IndexedStorage;
}
declare class IndexedTransaction extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        index?: number;
        data?: TransactionData;
    });
    get index(): number;
    set index(value: number);
    get data(): TransactionData;
    set data(value: TransactionData);
    get has_data(): boolean;
    static fromObject(data: {
        index?: number;
        data?: ReturnType<typeof TransactionData.prototype.toObject>;
    }): IndexedTransaction;
    toObject(): {
        index?: number;
        data?: ReturnType<typeof TransactionData.prototype.toObject>;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IndexedTransaction;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): IndexedTransaction;
}

/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.3
 * source: sdk/prover.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */

declare enum ErrCode$1 {
    ERROR_UNDEFINED = 0,
    ERROR_DEFAULT = 1,
    ERROR_INVALID_INPUT = 2,
    ERROR_INVALID_CUSTOM_INPUT = 3,
    ERROR_FAILED_TO_PROVE = 4
}
declare class ProveRequest extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        receipts?: IndexedReceipt[];
        storages?: IndexedStorage[];
        transactions?: IndexedTransaction[];
        custom_input?: CustomInput$1;
        src_chain_id?: number;
    });
    get receipts(): IndexedReceipt[];
    set receipts(value: IndexedReceipt[]);
    get storages(): IndexedStorage[];
    set storages(value: IndexedStorage[]);
    get transactions(): IndexedTransaction[];
    set transactions(value: IndexedTransaction[]);
    get custom_input(): CustomInput$1;
    set custom_input(value: CustomInput$1);
    get has_custom_input(): boolean;
    get src_chain_id(): number;
    set src_chain_id(value: number);
    static fromObject(data: {
        receipts?: ReturnType<typeof IndexedReceipt.prototype.toObject>[];
        storages?: ReturnType<typeof IndexedStorage.prototype.toObject>[];
        transactions?: ReturnType<typeof IndexedTransaction.prototype.toObject>[];
        custom_input?: ReturnType<typeof CustomInput$1.prototype.toObject>;
        src_chain_id?: number;
    }): ProveRequest;
    toObject(): {
        receipts?: ReturnType<typeof IndexedReceipt.prototype.toObject>[];
        storages?: ReturnType<typeof IndexedStorage.prototype.toObject>[];
        transactions?: ReturnType<typeof IndexedTransaction.prototype.toObject>[];
        custom_input?: ReturnType<typeof CustomInput$1.prototype.toObject>;
        src_chain_id?: number;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProveRequest;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): ProveRequest;
}
declare class ProveResponse extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        err?: Err;
        proof?: string;
        circuit_info?: AppCircuitInfo;
    });
    get err(): Err;
    set err(value: Err);
    get has_err(): boolean;
    get proof(): string;
    set proof(value: string);
    get circuit_info(): AppCircuitInfo;
    set circuit_info(value: AppCircuitInfo);
    get has_circuit_info(): boolean;
    static fromObject(data: {
        err?: ReturnType<typeof Err.prototype.toObject>;
        proof?: string;
        circuit_info?: ReturnType<typeof AppCircuitInfo.prototype.toObject>;
    }): ProveResponse;
    toObject(): {
        err?: ReturnType<typeof Err.prototype.toObject>;
        proof?: string;
        circuit_info?: ReturnType<typeof AppCircuitInfo.prototype.toObject>;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProveResponse;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): ProveResponse;
}
declare class ProveAsyncResponse extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        err?: Err;
        proof_id?: string;
        circuit_info?: AppCircuitInfo;
    });
    get err(): Err;
    set err(value: Err);
    get has_err(): boolean;
    get proof_id(): string;
    set proof_id(value: string);
    get circuit_info(): AppCircuitInfo;
    set circuit_info(value: AppCircuitInfo);
    get has_circuit_info(): boolean;
    static fromObject(data: {
        err?: ReturnType<typeof Err.prototype.toObject>;
        proof_id?: string;
        circuit_info?: ReturnType<typeof AppCircuitInfo.prototype.toObject>;
    }): ProveAsyncResponse;
    toObject(): {
        err?: ReturnType<typeof Err.prototype.toObject>;
        proof_id?: string;
        circuit_info?: ReturnType<typeof AppCircuitInfo.prototype.toObject>;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProveAsyncResponse;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): ProveAsyncResponse;
}
declare class GetProofResponse extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        err?: Err;
        proof?: string;
    });
    get err(): Err;
    set err(value: Err);
    get has_err(): boolean;
    get proof(): string;
    set proof(value: string);
    static fromObject(data: {
        err?: ReturnType<typeof Err.prototype.toObject>;
        proof?: string;
    }): GetProofResponse;
    toObject(): {
        err?: ReturnType<typeof Err.prototype.toObject>;
        proof?: string;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetProofResponse;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): GetProofResponse;
}
declare class Err extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        code?: ErrCode$1;
        msg?: string;
    });
    get code(): ErrCode$1;
    set code(value: ErrCode$1);
    get msg(): string;
    set msg(value: string);
    static fromObject(data: {
        code?: ErrCode$1;
        msg?: string;
    }): Err;
    toObject(): {
        code?: ErrCode$1;
        msg?: string;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Err;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): Err;
}

/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.3
 * source: brevis/gateway.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */

declare enum ErrCode {
    ERROR_CODE_UNDEFINED = 0,
    ERROR_CODE_SLOT_VALUE_PROOF_GENERATION_FAILED = 1,
    ERROR_CODE_TRANSACTION_PROOF_GENERATION_FAILED = 2
}
declare enum QueryOption {
    ZK_MODE = 0,
    OP_MODE = 1
}
declare class ErrMsg extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        code?: ErrCode;
        msg?: string;
    });
    get code(): ErrCode;
    set code(value: ErrCode);
    get msg(): string;
    set msg(value: string);
    static fromObject(data: {
        code?: ErrCode;
        msg?: string;
    }): ErrMsg;
    toObject(): {
        code?: ErrCode;
        msg?: string;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ErrMsg;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): ErrMsg;
}
declare class PrepareQueryResponse extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        err?: ErrMsg;
        query_key?: QueryKey;
        fee?: string;
    });
    get err(): ErrMsg;
    set err(value: ErrMsg);
    get has_err(): boolean;
    get query_key(): QueryKey;
    set query_key(value: QueryKey);
    get has_query_key(): boolean;
    get fee(): string;
    set fee(value: string);
    static fromObject(data: {
        err?: ReturnType<typeof ErrMsg.prototype.toObject>;
        query_key?: ReturnType<typeof QueryKey.prototype.toObject>;
        fee?: string;
    }): PrepareQueryResponse;
    toObject(): {
        err?: ReturnType<typeof ErrMsg.prototype.toObject>;
        query_key?: ReturnType<typeof QueryKey.prototype.toObject>;
        fee?: string;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PrepareQueryResponse;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): PrepareQueryResponse;
}
declare class QueryKey extends pb_1.Message {
    #private;
    constructor(data?: any[] | {
        query_hash?: string;
        nonce?: number;
    });
    get query_hash(): string;
    set query_hash(value: string);
    get nonce(): number;
    set nonce(value: number);
    static fromObject(data: {
        query_hash?: string;
        nonce?: number;
    }): QueryKey;
    toObject(): {
        query_hash?: string;
        nonce?: number;
    };
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueryKey;
    serializeBinary(): Uint8Array;
    static deserializeBinary(bytes: Uint8Array): QueryKey;
}

type CustomInput = Record<string, CircuitValue | CircuitValue[]>;
type CircuitDataType = 'Uint248' | 'Uint521' | 'Int248' | 'Bytes32' | 'Uint32' | 'Uint64';
interface CircuitValue {
    type: CircuitDataType;
    data: string;
}
declare function asUint248(input: string): CircuitValue;
declare function asUint521(input: string): CircuitValue;
declare function asInt248(input: string): CircuitValue;
declare function asBytes32(input: string): CircuitValue;

declare class ProofRequest {
    private readonly receipts;
    private readonly storages;
    private readonly transactions;
    private customInput?;
    getReceipts(): IndexedReceipt[];
    getStorages(): IndexedStorage[];
    getTransactions(): IndexedTransaction[];
    addReceipt(data: ReceiptData, index?: number): void;
    addStorage(data: StorageData, index?: number): void;
    addTransaction(data: TransactionData, index?: number): void;
    setCustomInput(data: CustomInput): void;
    build(): ProveRequest;
}

interface SubmitResponse {
    queryKey: QueryKey;
    fee: string;
}
interface FinalResult {
    queryKey: QueryKey;
    tx?: string;
    success: boolean;
}
declare class Brevis {
    private readonly client;
    constructor(url: string);
    submit(request: ProofRequest, proof: ProveResponse, srcChainId: number, dstChainId: number, option: QueryOption, apiKey: string, callbackAddress: string): Promise<SubmitResponse>;
    prepareQuery(request: ProofRequest, circuitInfo: AppCircuitInfo, srcChainId: number, dstChainId: number, option: QueryOption, apiKey: string, callbackAddress: string): Promise<PrepareQueryResponse>;
    submitProof(queryKey: QueryKey, dstChainId: number, proof: string): Promise<void>;
    wait(queryKey: QueryKey, dstChainId: number): Promise<FinalResult>;
    private _prepareQuery;
    private _prepareQueryForBrevisPartnerFlow;
    private _submitProof;
    private getQueryStatus;
    private buildReceiptInfo;
    private buildStorageInfo;
    private buildTransactionInfo;
}

declare class Prover {
    private readonly client;
    constructor(url: string);
    prove(request: ProofRequest): Promise<ProveResponse>;
    proveAsync(request: ProofRequest): Promise<ProveAsyncResponse>;
    getProof(id: string): Promise<GetProofResponse>;
}

export { Brevis, ErrCode$1 as ErrCode, Field, ProofRequest, ProveResponse, Prover, ReceiptData, StorageData, TransactionData, asBytes32, asInt248, asUint248, asUint521 };
